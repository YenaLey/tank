<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Interactive Tank (PBR & Tangent Space Normal)</title>
    <style>
      body,
      html {
        margin: 0;
        padding: 0;
        overflow: hidden;
      }
      canvas {
        display: block;
        outline: none;
      }
    </style>
  </head>
  <body>
    <canvas id="webgpu-canvas" tabindex="1"></canvas>
    <script type="importmap">
      {
        "imports": {
          "three": "https://threejs.org/build/three.module.min.js",
          "three/addons/": "https://threejs.org/examples/jsm/",
          "wgpu-matrix": "https://wgpu-matrix.org/dist/2.x/wgpu-matrix.module.min.js"
        }
      }
    </script>
    <script type="module">
      import * as THREE from "three";
      import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
      import { OBJLoader } from "three/addons/loaders/OBJLoader.js";
      import { vec2, vec3, vec4, mat4, utils } from "wgpu-matrix";

      const format_depth_texture = "depth24plus";

      class UI {
        static NONE = 0;
        static ROTATING = 1;
        static TRANSLATING = 2;
        static mouseMove = UI.NONE;
        static camera = {
          fovy: 45,
          position: vec3.create(-0.2, -0.5, -4),
          near: 0.1,
          far: 100,
        };
        static matrices = { P: null, R: null, VP: null };

        static onmousedown(ev) {
          if (ev.buttons === 1) {
            if (ev.metaKey || ev.ctrlKey) UI.mouseMove = UI.TRANSLATING;
            else UI.mouseMove = UI.ROTATING;
          }
        }
        static onmouseup(ev) {
          UI.mouseMove = UI.NONE;
        }
        static onmousemove(ev) {
          let offset = [ev.movementX, ev.movementY];
          if (UI.mouseMove == UI.ROTATING) {
            UI.update_VP();
            let axis = unproject_vector(
              [offset[1], offset[0], 0],
              UI.matrices.VP,
              [0, 0, UI.canvas.clientWidth, UI.canvas.clientHeight]
            );
            UI.matrices.R = mat4.rotate(
              UI.matrices.R,
              [axis[0], axis[1], axis[2]],
              utils.degToRad(vec2.lenSq(offset) * 0.1)
            );
          } else if (UI.mouseMove == UI.TRANSLATING) {
            UI.update_VP();
            let by = unproject_vector(
              [offset[0], -offset[1], 0],
              UI.matrices.VP,
              [0, 0, UI.canvas.clientWidth, UI.canvas.clientHeight]
            );
            UI.camera.position = vec3.add(
              UI.camera.position,
              vec3.transformMat4(
                vec3.create(by[0], by[1], by[2]),
                UI.matrices.R
              )
            );
          }
        }
        static onwheel(ev) {
          ev.preventDefault();
          UI.camera.position[2] = -Math.max(
            1,
            Math.min(-UI.camera.position[2] + ev.deltaY * 0.01, 50)
          );
          UI.update_VP();
        }
        static update_VP() {
          UI.matrices.P = mat4.perspective(
            utils.degToRad(UI.camera.fovy),
            UI.canvas.width / UI.canvas.height,
            UI.camera.near,
            UI.camera.far
          );
          if (!UI.matrices.R) UI.matrices.R = mat4.identity();
          let T = mat4.translate(UI.matrices.P, UI.camera.position);
          UI.matrices.VP = mat4.multiply(T, UI.matrices.R);
        }
      }

      function project(p_obj, MVP, viewport) {
        let tmp = vec4.transformMat4(p_obj, MVP);
        tmp = tmp.map((x) => x / tmp[3]);
        for (let i = 0; i < 2; i++)
          tmp[i] = (0.5 * tmp[i] + 0.5) * viewport[i + 2] + viewport[i];
        return tmp;
      }

      function unproject(p_win, MVP, viewport) {
        let MVP_inv = mat4.invert(MVP);
        let tmp = mat4.clone(p_win);
        for (let i = 0; i < 2; i++)
          tmp[i] = (2.0 * (tmp[i] - viewport[i])) / viewport[i + 2] - 1.0;
        let p_obj = vec4.transformMat4(tmp, MVP_inv);
        p_obj = p_obj.map((x) => x / p_obj[3]);
        return p_obj;
      }

      function unproject_vector(vec_win, MVP, viewport) {
        let org_win = project([0, 0, 0, 1], MVP, viewport);
        let vec = unproject(
          [
            org_win[0] + vec_win[0],
            org_win[1] + vec_win[1],
            org_win[2] + vec_win[2],
            1,
          ],
          MVP,
          viewport
        );
        return vec;
      }

      function computeTangents(positions, normals, uvs, indices) {
        const vertexCount = positions.length / 3;
        const tangents = new Float32Array(vertexCount * 3);
        const bitangents = new Float32Array(vertexCount * 3);

        for (let i = 0; i < indices.length; i += 3) {
          const i0 = indices[i],
            i1 = indices[i + 1],
            i2 = indices[i + 2];
          const x0 = positions[i0 * 3],
            y0 = positions[i0 * 3 + 1],
            z0 = positions[i0 * 3 + 2];
          const x1 = positions[i1 * 3],
            y1 = positions[i1 * 3 + 1],
            z1 = positions[i1 * 3 + 2];
          const x2 = positions[i2 * 3],
            y2 = positions[i2 * 3 + 1],
            z2 = positions[i2 * 3 + 2];

          const u0 = uvs[i0 * 2],
            v0 = uvs[i0 * 2 + 1];
          const u1 = uvs[i1 * 2],
            v1 = uvs[i1 * 2 + 1];
          const u2 = uvs[i2 * 2],
            v2 = uvs[i2 * 2 + 1];

          const E1x = x1 - x0,
            E1y = y1 - y0,
            E1z = z1 - z0;
          const E2x = x2 - x0,
            E2y = y2 - y0,
            E2z = z2 - z0;
          const dU1 = u1 - u0,
            dV1 = v1 - v0;
          const dU2 = u2 - u0,
            dV2 = v2 - v0;

          let denom = dU1 * dV2 - dU2 * dV1;
          if (denom === 0.0) continue;
          const r = 1.0 / denom;
          const Tx = (E1x * dV2 - E2x * dV1) * r;
          const Ty = (E1y * dV2 - E2y * dV1) * r;
          const Tz = (E1z * dV2 - E2z * dV1) * r;
          const Bx = (E2x * dU1 - E1x * dU2) * r;
          const By = (E2y * dU1 - E1y * dU2) * r;
          const Bz = (E2z * dU1 - E1z * dU2) * r;

          tangents[i0 * 3] += Tx;
          tangents[i0 * 3 + 1] += Ty;
          tangents[i0 * 3 + 2] += Tz;
          tangents[i1 * 3] += Tx;
          tangents[i1 * 3 + 1] += Ty;
          tangents[i1 * 3 + 2] += Tz;
          tangents[i2 * 3] += Tx;
          tangents[i2 * 3 + 1] += Ty;
          tangents[i2 * 3 + 2] += Tz;

          bitangents[i0 * 3] += Bx;
          bitangents[i0 * 3 + 1] += By;
          bitangents[i0 * 3 + 2] += Bz;
          bitangents[i1 * 3] += Bx;
          bitangents[i1 * 3 + 1] += By;
          bitangents[i1 * 3 + 2] += Bz;
          bitangents[i2 * 3] += Bx;
          bitangents[i2 * 3 + 1] += By;
          bitangents[i2 * 3 + 2] += Bz;
        }

        for (let i = 0; i < vertexCount; i++) {
          const nx = normals[i * 3],
            ny = normals[i * 3 + 1],
            nz = normals[i * 3 + 2];
          let tx = tangents[i * 3],
            ty = tangents[i * 3 + 1],
            tz = tangents[i * 3 + 2];
          const NdotT = nx * tx + ny * ty + nz * tz;
          tx = tx - NdotT * nx;
          ty = ty - NdotT * ny;
          tz = tz - NdotT * nz;
          let tlen = Math.sqrt(tx * tx + ty * ty + tz * tz);
          if (tlen > 0.0) {
            tx /= tlen;
            ty /= tlen;
            tz /= tlen;
          }
          tangents[i * 3] = tx;
          tangents[i * 3 + 1] = ty;
          tangents[i * 3 + 2] = tz;

          let bx = bitangents[i * 3],
            by = bitangents[i * 3 + 1],
            bz = bitangents[i * 3 + 2];
          const NdotB = nx * bx + ny * by + nz * bz;
          bx = bx - NdotB * nx;
          by = by - NdotB * ny;
          bz = bz - NdotB * nz;
          let blen = Math.sqrt(bx * bx + by * by + bz * bz);
          if (blen > 0.0) {
            bx /= blen;
            by /= blen;
            bz /= blen;
          }
          bitangents[i * 3] = bx;
          bitangents[i * 3 + 1] = by;
          bitangents[i * 3 + 2] = bz;
        }

        return { tangents, bitangents };
      }

      async function loadAllMeshesFromGLTF(device, url) {
        const loader = new GLTFLoader();
        const gltf = await new Promise((resolve, reject) => {
          loader.load(
            url,
            (g) => resolve(g),
            undefined,
            (e) => reject(e)
          );
        });

        let meshes = [];
        gltf.scene.traverse((c) => {
          if (c.isMesh && c.geometry) meshes.push(c);
        });
        if (meshes.length == 0) throw Error("No meshes found in gltf");

        function createBufferFromArray(arr, usage) {
          const buf = device.createBuffer({
            size: arr.byteLength,
            usage: usage | GPUBufferUsage.COPY_DST,
          });
          device.queue.writeBuffer(buf, 0, arr);
          return buf;
        }

        let meshData = [];
        for (let obj of meshes) {
          const positions = obj.geometry.attributes.position.array;

          const normals = obj.geometry.attributes.normal.array;
          const uvs = obj.geometry.attributes.uv
            ? obj.geometry.attributes.uv.array
            : new Float32Array((positions.length / 3) * 2);
          let indices = obj.geometry.index.array;
          if (!(indices instanceof Uint32Array)) {
            const tmp = new Uint32Array(indices.length);
            for (let i = 0; i < indices.length; i++) tmp[i] = indices[i];
            indices = tmp;
          }

          // Tangent, Bitangent 계산
          const { tangents, bitangents } = computeTangents(
            positions,
            normals,
            uvs,
            indices
          );

          const posBuffer = createBufferFromArray(
            positions,
            GPUBufferUsage.VERTEX
          );
          const normalBuffer = createBufferFromArray(
            normals,
            GPUBufferUsage.VERTEX
          );
          const uvBuffer = createBufferFromArray(uvs, GPUBufferUsage.VERTEX);
          const tangentBuffer = createBufferFromArray(
            tangents,
            GPUBufferUsage.VERTEX
          );
          const bitangentBuffer = createBufferFromArray(
            bitangents,
            GPUBufferUsage.VERTEX
          );
          const indexBuffer = createBufferFromArray(
            indices,
            GPUBufferUsage.INDEX
          );
          meshData.push({
            posBuffer,
            normalBuffer,
            uvBuffer,
            tangentBuffer,
            bitangentBuffer,
            indexBuffer,
            indexCount: indices.length,
          });
        }
        return meshData;
      }

      async function loadImageAsTexture(device, url) {
        const img = new Image();
        img.src = url;
        await img.decode();
        const bitmap = await createImageBitmap(img, {
          colorSpaceConversion: "none",
        });
        const texture = device.createTexture({
          label: url,
          format: "rgba8unorm",
          size: [bitmap.width, bitmap.height],
          usage:
            GPUTextureUsage.TEXTURE_BINDING |
            GPUTextureUsage.COPY_DST |
            GPUTextureUsage.RENDER_ATTACHMENT,
        });
        device.queue.copyExternalImageToTexture(
          { source: bitmap, flipY: true },
          { texture: texture },
          [bitmap.width, bitmap.height]
        );
        return texture;
      }

      function createSampler(device) {
        return device.createSampler({
          magFilter: "linear",
          minFilter: "linear",
          mipmapFilter: "linear",
          maxAnisotropy: 16,
        });
      }

      function createDepthTexture(device, width, height, format) {
        return device.createTexture({
          size: [width, height],
          format: format,
          usage: GPUTextureUsage.RENDER_ATTACHMENT,
        });
      }

      async function loadOBJAsMeshes(device, url) {
        const loader = new OBJLoader();
        const obj = await new Promise((resolve, reject) => {
          loader.load(
            url,
            (obj) => resolve(obj),
            undefined,
            (e) => reject(e)
          );
        });
        // obj.children 중 Mesh 찾아 geometry 읽기
        let meshes = [];
        obj.traverse((c) => {
          if (c.isMesh && c.geometry) meshes.push(c);
        });
        if (meshes.length == 0) throw Error("No meshes found in obj");

        function createBufferFromArray(arr, usage) {
          const buf = device.createBuffer({
            size: arr.byteLength,
            usage: usage | GPUBufferUsage.COPY_DST,
          });
          device.queue.writeBuffer(buf, 0, arr);
          return buf;
        }

        let meshData = [];
        for (let m of meshes) {
          const geom = m.geometry;
          const positions = geom.attributes.position.array;
          const normals = geom.attributes.normal.array;
          let uvs;
          if (geom.attributes.uv) uvs = geom.attributes.uv.array;
          else uvs = new Float32Array((positions.length / 3) * 2);
          let indices;
          if (geom.index) indices = geom.index.array;
          else {
            // 인덱스가 없는 경우 삼각 스트립 가정X. 그냥 순서대로 (0,1,2)...
            let count = positions.length / 3;
            indices = new Uint32Array(count);
            for (let i = 0; i < count; i++) indices[i] = i;
          }

          const { tangents, bitangents } = computeTangents(
            positions,
            normals,
            uvs,
            indices
          );

          const posBuffer = createBufferFromArray(
            positions,
            GPUBufferUsage.VERTEX
          );
          const normalBuffer = createBufferFromArray(
            normals,
            GPUBufferUsage.VERTEX
          );
          const uvBuffer = createBufferFromArray(uvs, GPUBufferUsage.VERTEX);
          const tangentBuffer = createBufferFromArray(
            tangents,
            GPUBufferUsage.VERTEX
          );
          const bitangentBuffer = createBufferFromArray(
            bitangents,
            GPUBufferUsage.VERTEX
          );
          const indexBuffer = createBufferFromArray(
            indices,
            GPUBufferUsage.INDEX
          );
          meshData.push({
            posBuffer,
            normalBuffer,
            uvBuffer,
            tangentBuffer,
            bitangentBuffer,
            indexBuffer,
            indexCount: indices.length,
          });
        }
        return meshData;
      }

      const vertexShaderWGSL = `@group(0) @binding(0) var<uniform> sceneUniform: mat4x4<f32>;
@group(0) @binding(1) var<uniform> modelMatrix: mat4x4<f32>;
@group(0) @binding(2) var<uniform> normalMatrix: mat4x4<f32>;

struct VertexInput {
  @location(0) position: vec3<f32>,
  @location(1) normal: vec3<f32>,
  @location(2) uv: vec2<f32>,
  @location(3) tangent: vec3<f32>,
  @location(4) bitangent: vec3<f32>,
};

struct VertexOutput {
  @builtin(position) position: vec4<f32>,
  @location(0) fragPos: vec3<f32>,
  @location(1) normal: vec3<f32>,
  @location(2) uv: vec2<f32>,
  @location(3) tangent: vec3<f32>,
  @location(4) bitangent: vec3<f32>,
};

@vertex
fn main(input: VertexInput) -> VertexOutput {
  var output: VertexOutput;
  let worldPos = modelMatrix * vec4<f32>(input.position, 1.0);
  output.position = sceneUniform * worldPos;
  output.fragPos = worldPos.xyz;

  output.normal = normalize((normalMatrix * vec4<f32>(input.normal, 0.0)).xyz);
  output.tangent = normalize((modelMatrix * vec4<f32>(input.tangent, 0.0)).xyz);
  output.bitangent = normalize((modelMatrix * vec4<f32>(input.bitangent, 0.0)).xyz);

  output.uv = input.uv;
  return output;
}`;

      const fragmentShaderWGSL = `
      @group(0) @binding(3) var<uniform> lightDirection: vec3<f32>;
      @group(0) @binding(4) var<uniform> lightDirection2: vec3<f32>;
      @group(0) @binding(5) var colorTex: texture_2d<f32>;
      @group(0) @binding(6) var etcTex: texture_2d<f32>;
      @group(0) @binding(7) var normalTex: texture_2d<f32>;
      @group(0) @binding(8) var mySampler: sampler;

      const PI = 3.14159265359;

      fn fresnelSchlick(cosTheta: f32, F0: vec3<f32>) -> vec3<f32> {
        return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);
      }

      fn ndfGGX(N: vec3<f32>, H: vec3<f32>, roughness: f32) -> f32 {
        let a = roughness * roughness;
        let a2 = a * a;
        let NdotH = max(dot(N, H), 0.0);
        let NdotH2 = NdotH * NdotH;
        let denom = NdotH2 * (a2 - 1.0) + 1.0;
        return a2 / (PI * denom * denom);
      }

      fn geometrySmith(N: vec3<f32>, V: vec3<f32>, L: vec3<f32>, roughness: f32) -> f32 {
        let k = (roughness + 1.0)*(roughness + 1.0)/8.0;
        let NdotV = max(dot(N,V),0.0);
        let NdotL = max(dot(N,L),0.0);
        let G1V = NdotV/(NdotV*(1.0-k)+k);
        let G1L = NdotL/(NdotL*(1.0-k)+k);
        return G1V * G1L;
      }

      struct VertexOutput {
        @builtin(position) position: vec4<f32>,
        @location(0) fragPos: vec3<f32>,
        @location(1) normal: vec3<f32>,
        @location(2) uv: vec2<f32>,
        @location(3) tangent: vec3<f32>,
        @location(4) bitangent: vec3<f32>,
      };

 @fragment
      fn main(input: VertexOutput)->@location(0) vec4<f32> {
        let baseColor_srgb = textureSample(colorTex,mySampler,input.uv).rgb;
        var baseColor = pow(baseColor_srgb, vec3<f32>(2.2));

        let etcColor = textureSample(etcTex,mySampler,input.uv);
        let AO = etcColor.r;
        var roughness = etcColor.g;
        var metallic = etcColor.b;

        let normalSample = textureSample(normalTex, mySampler, input.uv).rgb;
        let N_map = normalSample * 2.0 - 1.0;
        let tangentNormal = normalize(-N_map);

        let T = normalize(input.tangent);
        let B = normalize(input.bitangent);
        let N = normalize(input.normal);
        let TBN = mat3x3<f32>(T, B, N);

        let worldNormal = normalize(TBN * tangentNormal);

        let L = normalize(-lightDirection);
        let L2 = normalize(-lightDirection2);
        let V = normalize(-input.fragPos);
        let H = normalize(L + V);

        let NdotV = max(dot(worldNormal, V),0.0);
        let NdotL = max(dot(worldNormal, L),0.0);
        let NdotL2 = max(dot(worldNormal, L2),0.0);

        let NDF = ndfGGX(worldNormal, H, roughness);
        let G = geometrySmith(worldNormal, V, L, roughness);
        let F0 = mix(vec3<f32>(0.04,0.04,0.04), baseColor, metallic);
        let F = fresnelSchlick(max(dot(H, V),0.0), F0);

        let kS = F * (NDF * G) / (4.0 * NdotV * NdotL + 0.001);
        let kD = (vec3<f32>(1.0)-F)*(1.0-metallic);

        let diffuse = NdotL * baseColor;
        let diffuse2 = NdotL2 * baseColor;
        let ambientIntensity = 0.005;
        let ambient = AO * vec3<f32>(ambientIntensity, ambientIntensity, ambientIntensity);

        var finalColor = ambient + kD*diffuse + kS + kD*diffuse2*0.5; // 두번째 광원 조금 약하게

        let gamma = 2.2;
        finalColor = pow(finalColor, vec3<f32>(1.0/gamma));
        return vec4<f32>(finalColor, 1.0);
      }
    `;

      function createRenderPipeline(
        device,
        vertexModule,
        fragmentModule,
        depthFormat,
        preferredFormat
      ) {
        return device.createRenderPipeline({
          layout: "auto",
          vertex: {
            module: vertexModule,
            entryPoint: "main",
            buffers: [
              {
                arrayStride: 4 * 3, // position
                attributes: [
                  { shaderLocation: 0, offset: 0, format: "float32x3" },
                ],
              },
              {
                arrayStride: 4 * 3, // normal
                attributes: [
                  { shaderLocation: 1, offset: 0, format: "float32x3" },
                ],
              },
              {
                arrayStride: 4 * 2, // uv
                attributes: [
                  { shaderLocation: 2, offset: 0, format: "float32x2" },
                ],
              },
              {
                arrayStride: 4 * 3, // tangent
                attributes: [
                  { shaderLocation: 3, offset: 0, format: "float32x3" },
                ],
              },
              {
                arrayStride: 4 * 3, // bitangent
                attributes: [
                  { shaderLocation: 4, offset: 0, format: "float32x3" },
                ],
              },
            ],
          },
          fragment: {
            module: fragmentModule,
            entryPoint: "main",
            targets: [{ format: preferredFormat }],
          },
          primitive: { topology: "triangle-list" },
          depthStencil: {
            format: depthFormat,
            depthWriteEnabled: true,
            depthCompare: "less",
          },
        });
      }

      let shellLaunched = false;
      let shellPaused = false;
      let shellPos = [0, 0, 0];
      let shellVel = [0, 0, 0];
      const gravity = 9.8 * 0.3;
      const initialSpeed = 3.0;
      let M_barrel_glob = new Float32Array(16); // 전역 배럴 매트릭스

      // 스페이스: 포탄 발사
      // p: 포즈 토글
      window.addEventListener("keydown", (e) => {
        if (e.key === " ") {
          if (!shellLaunched && M_barrel_glob) {
            // M_barrel_glob 있어야
            shellLaunched = true;
            shellPaused = false;
            // 배럴 끝 위치
            let barrelEnd = [0.6, 0, 0, 1];
            let barrelEndWorld = vec4.transformMat4(barrelEnd, M_barrel_glob);
            shellPos = [
              barrelEndWorld[0],
              barrelEndWorld[1],
              barrelEndWorld[2],
            ];

            // 배럴 방향
            let dir = [M_barrel_glob[0], M_barrel_glob[1], M_barrel_glob[2]];
            let len = Math.sqrt(
              dir[0] * dir[0] + dir[1] * dir[1] + dir[2] * dir[2]
            );
            dir = [dir[0] / len, dir[1] / len, dir[2] / len];
            shellVel = [
              dir[0] * initialSpeed,
              dir[1] * initialSpeed,
              dir[2] * initialSpeed,
            ];
          }
        } else if (e.key === "p") {
          if (shellLaunched) shellPaused = !shellPaused;
        }
      });

      function updateShell() {
        if (shellLaunched && !shellPaused) {
          let dt = 1 / 60;
          shellVel[1] -= gravity * dt;
          shellPos[0] += shellVel[0] * dt;
          shellPos[1] += shellVel[1] * dt;
          shellPos[2] += shellVel[2] * dt;
          if (shellPos[1] < 0) {
            shellPos[1] = 0;
            shellVel = [0, 0, 0];
          }
        }
      }

      async function main() {
        const canvas = document.getElementById("webgpu-canvas");
        const adapter = await navigator.gpu.requestAdapter();
        const device = await adapter.requestDevice();
        const context = canvas.getContext("webgpu");
        const preferredFormat = navigator.gpu.getPreferredCanvasFormat();

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        context.configure({
          device: device,
          format: preferredFormat,
          alphaMode: "opaque",
        });

        canvas.onmousedown = UI.onmousedown;
        canvas.onmouseup = UI.onmouseup;
        canvas.onmousemove = UI.onmousemove;
        window.addEventListener("wheel", UI.onwheel, { passive: false });

        UI.canvas = canvas;
        UI.update_VP();

        // 탱크 로딩
        const meshData = await loadAllMeshesFromGLTF(device, "models/tank.glb");
        const shellData = await loadAllMeshesFromGLTF(
          device,
          "models/88mm_shell.glb"
        );
        // const shellData = await loadOBJAsMeshes(device, "models/shell.obj");

        // 텍스처 로딩
        const tankColor = await loadImageAsTexture(
          device,
          "textures/tank-color.jpg"
        );
        const tankEtc = await loadImageAsTexture(
          device,
          "textures/tank-etc.png"
        );
        const tankNormal = await loadImageAsTexture(
          device,
          "textures/tank-normal.png"
        );

        const shellColor = await loadImageAsTexture(
          device,
          "textures/shell-color.png"
        );
        const shellEtc = await loadImageAsTexture(
          device,
          "textures/shell-etc.png"
        );
        const shellNormal = await loadImageAsTexture(
          device,
          "textures/shell-normal.png"
        );

        const sampler = device.createSampler({
          magFilter: "linear",
          minFilter: "linear",
          mipmapFilter: "linear",
          maxAnisotropy: 16,
        });

        const sceneBuffer = device.createBuffer({
          size: 64,
          usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
        });
        const modelBuffer = device.createBuffer({
          size: 64,
          usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
        });
        const normalMatrixBuffer = device.createBuffer({
          size: 64,
          usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
        });
        const lightBuffer = device.createBuffer({
          size: 12,
          usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
        });
        const lightBuffer2 = device.createBuffer({
          size: 12,
          usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
        });

        function createPartIDBuffer(id) {
          const buf = device.createBuffer({
            size: 4,
            usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
            mappedAtCreation: true,
          });
          new Uint32Array(buf.getMappedRange())[0] = id;
          buf.unmap();
          return buf;
        }

        // partIDs: 0=body,1=turret,2=innerWheel,3=outerWheel,4=barrel,5=shell
        const partIDBuffer_Body = createPartIDBuffer(0);
        const partIDBuffer_Turret = createPartIDBuffer(1);
        const partIDBuffer_InnerWheel = createPartIDBuffer(2);
        const partIDBuffer_OuterWheel = createPartIDBuffer(3);
        const partIDBuffer_Barrel = createPartIDBuffer(4);
        const partIDBuffer_Shell = createPartIDBuffer(5); // 쉘 존재 시

        const vertexModule = device.createShaderModule({
          code: vertexShaderWGSL,
        });
        const fragmentModule = device.createShaderModule({
          code: fragmentShaderWGSL,
        });

        const pipeline = createRenderPipeline(
          device,
          vertexModule,
          fragmentModule,
          "depth24plus",
          preferredFormat
        );

        function createBindGroup(colorTex, etcTex, normalTex, partIDBuf) {
          return device.createBindGroup({
            layout: pipeline.getBindGroupLayout(0),
            entries: [
              { binding: 0, resource: { buffer: sceneBuffer } },
              { binding: 1, resource: { buffer: modelBuffer } },
              { binding: 2, resource: { buffer: normalMatrixBuffer } },
              { binding: 3, resource: { buffer: lightBuffer } }, // 첫 번째 광원
              { binding: 4, resource: { buffer: lightBuffer2 } }, // 두 번째 광원
              { binding: 5, resource: colorTex.createView() },
              { binding: 6, resource: etcTex.createView() },
              { binding: 7, resource: normalTex.createView() },
              { binding: 8, resource: sampler },
            ],
          });
        }

        const bindGroup_Body = createBindGroup(
          tankColor,
          tankEtc,
          tankNormal,
          partIDBuffer_Body
        );
        const bindGroup_Turret = createBindGroup(
          tankColor,
          tankEtc,
          tankNormal,
          partIDBuffer_Turret
        );
        const bindGroup_InnerWheel = createBindGroup(
          tankColor,
          tankEtc,
          tankNormal,
          partIDBuffer_InnerWheel
        );
        const bindGroup_OuterWheel = createBindGroup(
          tankColor,
          tankEtc,
          tankNormal,
          partIDBuffer_OuterWheel
        );
        const bindGroup_Barrel = createBindGroup(
          tankColor,
          tankEtc,
          tankNormal,
          partIDBuffer_Barrel
        );
        const bindGroup_Shell = createBindGroup(
          shellColor,
          shellEtc,
          shellNormal
        );

        // 그리드와 로컬 축 파이프라인
        const gridVertexCode = `
@group(0) @binding(0) var<uniform> sceneUniform: mat4x4<f32>;

struct VertexInput {
  @location(0) position: vec3<f32>,
  @location(1) color: vec3<f32>,
};
struct VertexOutput {
  @builtin(position) position: vec4<f32>,
  @location(0) color: vec3<f32>,
};

@vertex
fn main(input:VertexInput)->VertexOutput{
  var output:VertexOutput;
  output.position=sceneUniform*vec4<f32>(input.position,1.0);
  output.color=input.color;
  return output;
}

@fragment
fn fs_main(input:VertexOutput)->@location(0) vec4<f32>{
  return vec4<f32>(input.color,1.0);
}`;

        const gridModule = device.createShaderModule({ code: gridVertexCode });
        const gridPipeline = device.createRenderPipeline({
          layout: "auto",
          vertex: {
            module: gridModule,
            entryPoint: "main",
            buffers: [
              {
                arrayStride: 24,
                attributes: [
                  { shaderLocation: 0, offset: 0, format: "float32x3" },
                  { shaderLocation: 1, offset: 12, format: "float32x3" },
                ],
              },
            ],
          },
          fragment: {
            module: gridModule,
            entryPoint: "fs_main",
            targets: [{ format: preferredFormat }],
          },
          primitive: { topology: "line-list" },
          depthStencil: {
            format: "depth24plus",
            depthWriteEnabled: true,
            depthCompare: "less",
          },
        });

        const { buffer: gridBuffer, vertexCount: gridVertexCount } =
          (function createGridAndAxesBuffers(device) {
            const lines = [];
            lines.push(...[0, 0, 0, 1, 0, 0]);
            lines.push(...[1, 0, 0, 1, 0, 0]);
            lines.push(...[0, 0, 0, 0, 1, 0]);
            lines.push(...[0, 1, 0, 0, 1, 0]);
            lines.push(...[0, 0, 0, 0, 0, 1]);
            lines.push(...[0, 0, 1, 0, 0, 1]);

            for (let i = -5; i <= 5; i++) {
              lines.push(...[-5, 0, i, 1.0, 1.0, 1.0]);
              lines.push(...[5, 0, i, 1.0, 1.0, 1.0]);
              lines.push(...[i, 0, -5, 1.0, 1.0, 1.0]);
              lines.push(...[i, 0, 5, 1.0, 1.0, 1.0]);
            }

            const data = new Float32Array(lines);
            const buf = device.createBuffer({
              size: data.byteLength,
              usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
            });
            device.queue.writeBuffer(buf, 0, data);
            return { buffer: buf, vertexCount: data.length / 6 };
          })(device);

        const gridBindGroup = device.createBindGroup({
          layout: gridPipeline.getBindGroupLayout(0),
          entries: [{ binding: 0, resource: { buffer: sceneBuffer } }],
        });

        const localAxesVertexCode = `
@group(0) @binding(0) var<uniform> sceneUniform: mat4x4<f32>;
@group(0) @binding(1) var<uniform> modelMatrix: mat4x4<f32>;

struct VertexInput {
    @location(0) position: vec3<f32>,
    @location(1) color: vec3<f32>,
};
struct VertexOutput {
    @builtin(position) position: vec4<f32>,
    @location(0) color: vec3<f32>,
};

@vertex
fn main(input:VertexInput)->VertexOutput{
  var output:VertexOutput;
  let worldPos=modelMatrix*vec4<f32>(input.position,1.0);
  output.position=sceneUniform*worldPos;
  output.color=input.color;
  return output;
}`;

        const localAxesFragmentCode = `
struct VertexOutput {
    @builtin(position) position: vec4<f32>,
    @location(0) color: vec3<f32>,
};

@fragment
fn fs_main(input:VertexOutput)->@location(0) vec4<f32>{
  return vec4<f32>(input.color,1.0);
}`;

        const localAxesVertexModule = device.createShaderModule({
          code: localAxesVertexCode,
        });
        const localAxesFragmentModule = device.createShaderModule({
          code: localAxesFragmentCode,
        });

        const localAxesPipeline = device.createRenderPipeline({
          layout: "auto",
          vertex: {
            module: localAxesVertexModule,
            entryPoint: "main",
            buffers: [
              {
                arrayStride: 24,
                attributes: [
                  { shaderLocation: 0, offset: 0, format: "float32x3" },
                  { shaderLocation: 1, offset: 12, format: "float32x3" },
                ],
              },
            ],
          },
          fragment: {
            module: localAxesFragmentModule,
            entryPoint: "fs_main",
            targets: [{ format: preferredFormat }],
          },
          primitive: { topology: "line-list" },
          depthStencil: {
            format: "depth24plus",
            depthWriteEnabled: true,
            depthCompare: "less",
          },
        });

        const { buffer: localAxesBuffer, vertexCount: localAxesVertexCount } =
          (function createLocalAxesBuffer(device) {
            const axesLines = [];
            axesLines.push(...[0, 0, 0, 1, 0, 0]);
            axesLines.push(...[0.5, 0, 0, 1, 0, 0]);
            axesLines.push(...[0, 0, 0, 0, 1, 0]);
            axesLines.push(...[0, 0.5, 0, 0, 1, 0]);
            axesLines.push(...[0, 0, 0, 0, 0, 1]);
            axesLines.push(...[0, 0, 0.5, 0, 0, 1]);

            const data = new Float32Array(axesLines);
            const buf = device.createBuffer({
              size: data.byteLength,
              usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
            });
            device.queue.writeBuffer(buf, 0, data);
            return { buffer: buf, vertexCount: axesLines.length / 6 };
          })(device);

        const localAxesBindGroup = device.createBindGroup({
          layout: localAxesPipeline.getBindGroupLayout(0),
          entries: [
            { binding: 0, resource: { buffer: sceneBuffer } },
            { binding: 1, resource: { buffer: modelBuffer } },
          ],
        });

        const barrelPivot = [0, 0, 0.5];
        const tankState = {
          position: [0, 0, 0],
          rotation: 0,
          turretRotation: 0,
          barrelElevation: 0,
        };

        function updateShell() {
          if (shellLaunched && !shellPaused) {
            let dt = 1 / 60;
            shellVel[1] -= gravity * dt;
            shellPos[0] += shellVel[0] * dt;
            shellPos[1] += shellVel[1] * dt;
            shellPos[2] += shellVel[2] * dt;
            if (shellPos[1] < 0) {
              shellPos[1] = 0;
              shellVel = [0, 0, 0];
            }
          }
        }

        window.addEventListener("keydown", (e) => {
          let forwardX = Math.cos(tankState.rotation);
          let forwardZ = Math.sin(tankState.rotation);
          switch (e.key) {
            case "ArrowUp":
              tankState.position[0] += forwardX * 0.1;
              tankState.position[2] -= forwardZ * 0.1;
              break;
            case "ArrowDown":
              tankState.position[0] -= forwardX * 0.1;
              tankState.position[2] += forwardZ * 0.1;
              break;
            case "ArrowLeft":
              tankState.rotation += 0.05;
              break;
            case "ArrowRight":
              tankState.rotation -= 0.05;
              break;
            case "A":
              tankState.turretRotation += 0.05;
              break;
            case "D":
              tankState.turretRotation -= 0.05;
              break;
            case "W":
              tankState.barrelElevation += 0.05;
              if (tankState.barrelElevation > 0.5)
                tankState.barrelElevation = 0.5;
              break;
            case "S":
              tankState.barrelElevation -= 0.05;
              if (tankState.barrelElevation < -0.3)
                tankState.barrelElevation = -0.3;
              break;
          }
        });

        function drawPart(renderPass, M, bindGroup, mesh) {
          let invM = mat4.invert(M);
          let normalMat = mat4.transpose(invM);
          device.queue.writeBuffer(modelBuffer, 0, M);
          device.queue.writeBuffer(normalMatrixBuffer, 0, normalMat);

          renderPass.setPipeline(pipeline);
          renderPass.setBindGroup(0, bindGroup);
          renderPass.setVertexBuffer(0, mesh.posBuffer);
          renderPass.setVertexBuffer(1, mesh.normalBuffer);
          renderPass.setVertexBuffer(2, mesh.uvBuffer);
          renderPass.setVertexBuffer(3, mesh.tangentBuffer);
          renderPass.setVertexBuffer(4, mesh.bitangentBuffer);
          renderPass.setIndexBuffer(mesh.indexBuffer, "uint32");
          renderPass.drawIndexed(mesh.indexCount, 1, 0, 0, 0);
        }

        let M_barrel = mat4.identity();

        function renderFrame(time) {
          UI.update_VP();
          updateShell();

          let M_body = mat4.identity();
          M_body = mat4.translate(M_body, [
            tankState.position[0],
            0.46,
            tankState.position[2],
          ]);
          M_body = mat4.rotate(M_body, [0, 1, 0], tankState.rotation);

          let M_turret = mat4.rotate(
            M_body,
            [0, 1, 0],
            tankState.turretRotation
          );
          M_barrel = mat4.translate(M_turret, barrelPivot);
          M_barrel = mat4.rotateX(M_barrel, tankState.barrelElevation);
          M_barrel = mat4.translate(M_barrel, [
            -barrelPivot[0],
            -barrelPivot[1],
            -barrelPivot[2],
          ]);

          for (let i = 0; i < 16; i++) M_barrel_glob[i] = M_barrel[i]; // M_barrel_glob 갱신

          let M_innerWheel = M_body;
          let M_outerWheel = M_body;

          let M_shell_t = mat4.identity();
          M_shell_t = mat4.translate(M_shell_t, shellPos);
          // 포탄 크기 축소
          M_shell_t = mat4.scale(M_shell_t, [0.001, 0.001, 0.001]);

          // 라이트 설정
          const lightDir = new Float32Array([-2, 5, 2]);
          device.queue.writeBuffer(lightBuffer, 0, lightDir);
          const lightDir2 = new Float32Array([-2, 5, -2]);
          device.queue.writeBuffer(lightBuffer2, 0, lightDir2);

          device.queue.writeBuffer(sceneBuffer, 0, UI.matrices.VP);

          const depthTexture = createDepthTexture(
            device,
            canvas.width,
            canvas.height,
            "depth24plus"
          );
          const commandEncoder = device.createCommandEncoder();
          const textureView = context.getCurrentTexture().createView();

          const renderPass = commandEncoder.beginRenderPass({
            colorAttachments: [
              {
                view: textureView,
                loadOp: "clear",
                clearValue: { r: 0.3, g: 0.3, b: 0.3, a: 1 },
                storeOp: "store",
              },
            ],
            depthStencilAttachment: {
              view: depthTexture.createView(),
              depthLoadOp: "clear",
              depthClearValue: 1.0,
              depthStoreOp: "store",
            },
          });

          // 그리드
          renderPass.setPipeline(gridPipeline);
          renderPass.setBindGroup(0, gridBindGroup);
          renderPass.setVertexBuffer(0, gridBuffer);
          renderPass.draw(gridVertexCount, 1, 0, 0);

          // 탱크 파츠 드로우
          drawPart(renderPass, M_body, bindGroup_Body, meshData[0]);
          drawPart(renderPass, M_turret, bindGroup_Turret, meshData[1]);
          drawPart(renderPass, M_innerWheel, bindGroup_InnerWheel, meshData[2]);
          drawPart(renderPass, M_outerWheel, bindGroup_OuterWheel, meshData[3]);
          drawPart(renderPass, M_barrel, bindGroup_Barrel, meshData[4]);

          if (shellLaunched) {
            drawPart(renderPass, M_shell_t, bindGroup_Shell, shellData[0]);
          }

          // 로컬 축
          device.queue.writeBuffer(modelBuffer, 0, M_body);
          renderPass.setPipeline(localAxesPipeline);
          renderPass.setBindGroup(0, localAxesBindGroup);
          renderPass.setVertexBuffer(0, localAxesBuffer);
          renderPass.draw(localAxesVertexCount, 1, 0, 0);

          renderPass.end();
          device.queue.submit([commandEncoder.finish()]);
          requestAnimationFrame(renderFrame);
        }

        requestAnimationFrame(renderFrame);

        window.addEventListener("resize", () => {
          canvas.width = canvas.clientWidth * devicePixelRatio;
          canvas.height = canvas.clientHeight * devicePixelRatio;
          context.configure({ device, format: preferredFormat });
        });
      }

      main();
    </script>
  </body>
</html>
